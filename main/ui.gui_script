local UiModel = require "src.ui.model"

local BUTTON_COLOR = vmath.vector4(0.16, 0.24, 0.34, 0.9)
local BUTTON_ACTIVE_COLOR = vmath.vector4(0.28, 0.36, 0.48, 0.9)
local PANEL_COLOR = vmath.vector4(0.07, 0.09, 0.12, 0.82)
local TEXT_COLOR = vmath.vector4(0.92, 0.96, 1.0, 1.0)
local TEXT_SECONDARY_COLOR = vmath.vector4(0.65, 0.72, 0.82, 1.0)
local STATUS_COLOR = vmath.vector4(0.78, 0.84, 0.92, 1.0)
local PANEL_PADDING = 32
local PANEL_HEIGHT_RATIO = 0.60
local PANEL_WIDTH_RATIO = 0.80
local BUTTON_HEIGHT = 90
local BUTTON_WIDTH_RATIO = 0.46

local HASH_SPLASH = hash("splash")
local HASH_MENU = hash("menu")
local HASH_CREATE = hash("create")
local HASH_JOIN = hash("join")

local ACTION_SKIP_SPLASH = hash("skip_splash")
local ACTION_CREATE_ROOM = hash("create_room")
local ACTION_JOIN_ROOM = hash("join_room")
local ACTION_BACK_TO_MENU = hash("back_to_menu")
local ACTION_SEND_PING = hash("send_ping")

local HASH_UI_ACTION = hash("ui_action")
local HASH_STATE_CHANGED = hash("state_changed")
local HASH_LOGS_UPDATED = hash("logs_updated")
local HASH_STATUS_UPDATED = hash("status_updated")
local HASH_PEER_ID_CHANGED = hash("peer_id_changed")

local function state_from_hash(value)
    if value == HASH_SPLASH then return "splash" end
    if value == HASH_MENU then return "menu" end
    if value == HASH_CREATE then return "create" end
    if value == HASH_JOIN then return "join" end
    return nil
end

local EMPTY = {}

local function as_array(t)
    if not t then
        return EMPTY
    end
    return t
end

local function new_text(self, text, position, color)
    local node = gui.new_text_node(position, text)
    gui.set_color(node, color or TEXT_COLOR)
    gui.set_font(node, self.font)
    return node
end

local function new_label(self, text, position, color, pivot)
    local node = new_text(self, text, position, color)
    if pivot then
        gui.set_pivot(node, pivot)
    end
    gui.set_line_break(node, true)
    return node
end

local function new_button(self, label, position, size, action)
    local node = gui.new_box_node(position, size)
    gui.set_color(node, BUTTON_COLOR)
    local text_node = new_text(self, label, position)
    gui.set_pivot(text_node, gui.PIVOT_CENTER)
    return { node = node, text = text_node, action = action, default_color = vmath.vector4(BUTTON_COLOR) }
end

local function set_nodes_enabled(nodes, enabled)
    local value = enabled and 1 or 0
    for _, node in ipairs(nodes) do
        gui.set_enabled(node, value == 1)
    end
end

local function refresh_logs(self, state)
    local target
    if state == "create" then
        target = self.create_log_node
    elseif state == "join" then
        target = self.join_log_node
    end
    if not target then return end
    local lines = UiModel.get_logs(state)
    local text = table.concat(lines, "\n")
    gui.set_text(target, text)
end

local function refresh_status(self, state)
    if state == "create" and self.create_status_node then
        gui.set_text(self.create_status_node, UiModel.get_status(state))
    elseif state == "join" and self.join_status_node then
        gui.set_text(self.join_status_node, UiModel.get_status(state))
    end
end

local function update_peer_labels(self)
    local peer_id = UiModel.get_peer_id()
    local peer_ip = UiModel.get_peer_ip()
    local broadcast_ip = UiModel.get_broadcast_ip()
    local host_label = "Host Peer ID: " .. (peer_id ~= "" and peer_id or "unknown")
    local client_label = "Client Peer ID: " .. (peer_id ~= "" and peer_id or "unknown")
    if peer_ip ~= "" then
        host_label = host_label .. "\nIPv4: " .. peer_ip
    end
    if broadcast_ip ~= "" then
        client_label = client_label .. "\nBroadcast: " .. broadcast_ip
    end
    if self.create_peer_node then
        gui.set_text(self.create_peer_node, host_label)
    end
    if self.join_peer_node then
        gui.set_text(self.join_peer_node, client_label)
    end
end

local function set_state(self, state)
    if self.current_state == state then
        return
    end
    if self.current_state then
        set_nodes_enabled(self.screen_nodes[self.current_state] or EMPTY, false)
    end
    self.current_state = state
    set_nodes_enabled(self.screen_nodes[state] or EMPTY, true)
    self.active_buttons = as_array(self.screen_buttons[state])
    if state == "create" or state == "join" then
        refresh_logs(self, state)
        refresh_status(self, state)
    end
end

local function build_layout(self)
    local width = gui.get_width()
    local height = gui.get_height()
    if width == 0 or height == 0 then
        width = 640
        height = 1136
    end
    local center_x = width * 0.5
    local center_y = height * 0.5
    local spacing = height * 0.12
    local panel_width = width * PANEL_WIDTH_RATIO
    local panel_height = height * PANEL_HEIGHT_RATIO
    local panel_center = vmath.vector3(center_x, center_y, 0)
    local panel_left = panel_center.x - panel_width * 0.5 + PANEL_PADDING
    local panel_top = panel_center.y + panel_height * 0.5 - PANEL_PADDING

    -- Splash
    do
        local nodes = self.screen_nodes.splash
        local title = new_text(self, "LocalNetTest", vmath.vector3(center_x, center_y + 160, 0), TEXT_COLOR)
        gui.set_scale(title, vmath.vector3(1.6, 1.6, 1))
        local version = new_text(self, "Version 0.0.4", vmath.vector3(center_x, center_y + 80, 0), TEXT_SECONDARY_COLOR)
        local hint = new_text(self, "Tap to continue", vmath.vector3(center_x, center_y - 220, 0), TEXT_SECONDARY_COLOR)
        nodes[#nodes + 1] = title
        nodes[#nodes + 1] = version
        nodes[#nodes + 1] = hint
    end

    -- Menu
    do
        local nodes = self.screen_nodes.menu
        local buttons = self.screen_buttons.menu
        local title = new_text(self, "Main Menu", vmath.vector3(center_x, center_y + spacing, 0), TEXT_COLOR)
        gui.set_scale(title, vmath.vector3(1.4, 1.4, 1))
        nodes[#nodes + 1] = title
        local button_width = width * 0.55
        local button_height = 96
        local size = vmath.vector3(button_width, button_height, 0)

        local create_button = new_button(self, "Create Room", vmath.vector3(center_x, center_y, 0), size, ACTION_CREATE_ROOM)
        buttons[#buttons + 1] = create_button
        nodes[#nodes + 1] = create_button.node
        nodes[#nodes + 1] = create_button.text

        local join_button = new_button(self, "Join Room", vmath.vector3(center_x, center_y - spacing, 0), size, ACTION_JOIN_ROOM)
        buttons[#buttons + 1] = join_button
        nodes[#nodes + 1] = join_button.node
        nodes[#nodes + 1] = join_button.text
    end

    -- Create Room Screen
    do
        local nodes = self.screen_nodes.create
        local buttons = self.screen_buttons.create
        local panel_bg = gui.new_box_node(panel_center, vmath.vector3(panel_width, panel_height, 0))
        gui.set_color(panel_bg, PANEL_COLOR)
        nodes[#nodes + 1] = panel_bg

        local title = new_text(self, "Create Room", vmath.vector3(center_x, center_y + spacing * 1.25, 0), TEXT_COLOR)
        gui.set_scale(title, vmath.vector3(1.3, 1.3, 1))
        nodes[#nodes + 1] = title

        local peer = new_label(self, "Host Peer ID:", vmath.vector3(panel_left, panel_top, 0), STATUS_COLOR, gui.PIVOT_NW)
        nodes[#nodes + 1] = peer
        self.create_peer_node = peer

        local status = new_label(self, "", vmath.vector3(panel_left, panel_top - 40, 0), TEXT_SECONDARY_COLOR, gui.PIVOT_NW)
        gui.set_size(status, vmath.vector3(panel_width - PANEL_PADDING * 2, 96, 0))
        nodes[#nodes + 1] = status
        self.create_status_node = status

        local log_top = panel_top - 124
        local log_height = panel_height - 196
        local log_text = new_label(self, "", vmath.vector3(panel_left, log_top, 0), TEXT_COLOR, gui.PIVOT_NW)
        gui.set_line_break(log_text, true)
        gui.set_size(log_text, vmath.vector3(panel_width - PANEL_PADDING * 2, log_height, 0))
        nodes[#nodes + 1] = log_text
        self.create_log_node = log_text

        local back_size = vmath.vector3(width * 0.32, BUTTON_HEIGHT, 0)
        local back_button = new_button(self, "Back", vmath.vector3(center_x, panel_center.y - panel_height * 0.5 - spacing * 0.55, 0), back_size, ACTION_BACK_TO_MENU)
        buttons[#buttons + 1] = back_button
        nodes[#nodes + 1] = back_button.node
        nodes[#nodes + 1] = back_button.text
    end

    -- Join Room Screen
    do
        local nodes = self.screen_nodes.join
        local buttons = self.screen_buttons.join
        local panel_bg = gui.new_box_node(panel_center, vmath.vector3(panel_width, panel_height, 0))
        gui.set_color(panel_bg, PANEL_COLOR)
        nodes[#nodes + 1] = panel_bg

        local title = new_text(self, "Join Room", vmath.vector3(center_x, center_y + spacing * 1.25, 0), TEXT_COLOR)
        gui.set_scale(title, vmath.vector3(1.3, 1.3, 1))
        nodes[#nodes + 1] = title

        local peer = new_label(self, "Client Peer ID:", vmath.vector3(panel_left, panel_top, 0), STATUS_COLOR, gui.PIVOT_NW)
        nodes[#nodes + 1] = peer
        self.join_peer_node = peer

        local status = new_label(self, "", vmath.vector3(panel_left, panel_top - 40, 0), TEXT_SECONDARY_COLOR, gui.PIVOT_NW)
        gui.set_size(status, vmath.vector3(panel_width - PANEL_PADDING * 2, 96, 0))
        nodes[#nodes + 1] = status
        self.join_status_node = status

        local log_top = panel_top - 124
        local log_height = panel_height - 196
        local log_text = new_label(self, "", vmath.vector3(panel_left, log_top, 0), TEXT_COLOR, gui.PIVOT_NW)
        gui.set_line_break(log_text, true)
        gui.set_size(log_text, vmath.vector3(panel_width - PANEL_PADDING * 2, log_height, 0))
        nodes[#nodes + 1] = log_text
        self.join_log_node = log_text

        local button_width = width * BUTTON_WIDTH_RATIO
        local ping_button = new_button(self, "Ping", vmath.vector3(center_x - button_width * 0.5 - spacing * 0.15, panel_center.y - panel_height * 0.5 - spacing * 0.55, 0), vmath.vector3(button_width, BUTTON_HEIGHT, 0), ACTION_SEND_PING)
        buttons[#buttons + 1] = ping_button
        nodes[#nodes + 1] = ping_button.node
        nodes[#nodes + 1] = ping_button.text

        local back_button = new_button(self, "Back", vmath.vector3(center_x + button_width * 0.5 + spacing * 0.15, panel_center.y - panel_height * 0.5 - spacing * 0.55, 0), vmath.vector3(button_width, BUTTON_HEIGHT, 0), ACTION_BACK_TO_MENU)
        buttons[#buttons + 1] = back_button
        nodes[#nodes + 1] = back_button.node
        nodes[#nodes + 1] = back_button.text
    end

    for _, nodes in pairs(self.screen_nodes) do
        for _, node in ipairs(nodes) do
            gui.set_enabled(node, false)
        end
    end
end

function init(self)
    msg.post(".", "acquire_input_focus")
    self.font = hash("default")
    self.main_url = msg.url("main:/go#main")
    self.screen_nodes = { splash = {}, menu = {}, create = {}, join = {} }
    self.screen_buttons = { splash = {}, menu = {}, create = {}, join = {} }
    self.active_buttons = {}
    self.active_button = nil
    self.pending_skip = false

    build_layout(self)

    local initial_state = UiModel.get_state()
    set_state(self, initial_state)
    update_peer_labels(self)
    refresh_status(self, "create")
    refresh_status(self, "join")
end

local function reset_active_button(self)
    if self.active_button then
        gui.set_color(self.active_button.node, self.active_button.default_color)
        self.active_button = nil
    end
end

function on_message(self, message_id, message, sender)
    if message_id == HASH_STATE_CHANGED then
        local state = state_from_hash(message.state)
        if state then
            set_state(self, state)
        end
    elseif message_id == HASH_LOGS_UPDATED then
        local state = state_from_hash(message.state)
        if state then
            refresh_logs(self, state)
        end
    elseif message_id == HASH_STATUS_UPDATED then
        local state = state_from_hash(message.state)
        if state then
            refresh_status(self, state)
        end
    elseif message_id == HASH_PEER_ID_CHANGED then
        update_peer_labels(self)
    end
end

function on_input(self, action_id, action)
    if action_id ~= hash("touch") then
        return false
    end
    if action.pressed then
        if self.current_state == "splash" then
            self.pending_skip = true
        end
        local point = vmath.vector3(action.x, action.y, 0)
        for _, button in ipairs(self.active_buttons) do
            if gui.pick_node(button.node, point.x, point.y) then
                self.active_button = button
                gui.set_color(button.node, BUTTON_ACTIVE_COLOR)
                return true
            end
        end
    elseif action.released then
        local handled = false
        if self.current_state == "splash" and self.pending_skip then
            msg.post(self.main_url, HASH_UI_ACTION, { action = ACTION_SKIP_SPLASH })
            handled = true
        end
        self.pending_skip = false
        if self.active_button then
            local point = vmath.vector3(action.x, action.y, 0)
            local button = self.active_button
            if gui.pick_node(button.node, point.x, point.y) then
                msg.post(self.main_url, HASH_UI_ACTION, { action = button.action })
                handled = true
            end
            gui.set_color(button.node, button.default_color)
            self.active_button = nil
        end
        return handled
    elseif action.cancelled then
        self.pending_skip = false
        reset_active_button(self)
    end
    return self.active_button ~= nil
end

function final(self)
    reset_active_button(self)
end
